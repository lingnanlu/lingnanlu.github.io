<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="keywords" content="Code, Food, Music">
<meta property="og:type" content="website">
<meta property="og:title" content="Code, Food &amp; Music">
<meta property="og:url" content="http://asanelder.me/page/8/index.html">
<meta property="og:site_name" content="Code, Food &amp; Music">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Code, Food &amp; Music">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://asanelder.me/page/8/">





  <title>Code, Food & Music</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Code, Food & Music</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/20/java-regex-and-escape-character/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/20/java-regex-and-escape-character/" itemprop="url">为什么Java正则表达式中要使用\\来进行转义?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-20T00:00:00+08:00">
                2016-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先明确一个概念</p>
<h3 id="什么是转义"><a href="#什么是转义" class="headerlink" title="什么是转义?"></a>什么是转义?</h3><p>转义是一个动词,就是转换含义的意思,一个事物本来有一个含义,将之转义就是将之转换为另一个含义.</p>
<p>举个例子</p>
<p>字符t的本来含义就是字母表中的t, 而如果是\t则将t的含义转换成了制表符.这里\就是转义字符,其作用是改变其后字符的含义.而t就是被转义的字符.</p>
<p>由上可知,\出现在字符串中时,其含义就是<strong>转义字符</strong>, 如果想将之当做字面意义上的反斜线,则同样需要转义,即\\就表示一个普通意义上的反斜杠了.</p>
<p>既然知道了什么是转义,那么在Java语言中,哪些字符有另一个含义呢?也就是说哪些字符可以被转义?</p>
<h3 id="Java字符串中合法的转义"><a href="#Java字符串中合法的转义" class="headerlink" title="Java字符串中合法的转义"></a>Java字符串中合法的转义</h3><p><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.6" target="_blank" rel="noopener">Java语言规范</a>中提到</p>
<blockquote>
<p>It is a compile-time error if the character following a backslash in an escape sequence is not an ASCII  b ,  t ,  n ,  f ,  r ,  “ , ‘ ,  \ ,  0 ,  1 ,  2 ,  3 ,  4 ,  5 ,  6 , or  7 . The Unicode escape  \u is processed earlier</p>
</blockquote>
<p>所以,非以上字符的转义会导致编译错误. 即只有 b ,  t ,  n ,  f ,  r ,  “ ,  ‘,  \ ,  0 ,  1 ,  2 ,  3 ,  4 ,  5 ,  6 , or  7 可在被转义.</p>
<p>关于以上字符被转义后的含义,同样参照<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.6" target="_blank" rel="noopener">Java语言规范</a></p>
<p>那么,说了这些,和正则表达式有什么关系呢?</p>
<h3 id="为什么正则表达式中需要"><a href="#为什么正则表达式中需要" class="headerlink" title="为什么正则表达式中需要\\"></a>为什么正则表达式中需要\\</h3><p>我们知道,正则表达式中也有一些字符有双重含义,一重是其字面上的含义,另一重是其特殊含义.</p>
<p>如+, 字面含义是加号字符, 特殊含义是匹配一个或多个.如果使用转义字符\将之转换成另一个含义的话, 如下</p>
<p>\+</p>
<p>但是这样会报错, 为什么?</p>
<p>由以上Java语言规范中提到的只有 b ,  t ,  n ,  f ,  r ,  “ ,   ,  \ ,  0 ,  1 ,  2 ,  3 ,  4 ,  5 ,  6 , or  7才能被\进行转义,而+显然不在此中.</p>
<p>与此类似的情况还有很多, 如 <strong>?</strong> , <strong>.</strong> 等等.</p>
<p>那么如果能即不编译报错,又可以对这些字符进行转义呢?</p>
<p>Java定义了一个新的转义方式, 那就是\\</p>
<p>所以可以这样</p>
<p>\\+</p>
<p>而以上这种也没有违反Java语言规范中的定义,所以不会导致编译错误.</p>
<p>所以可以认为,\\是Java为了将正则表达式中的特殊字符(不包含在 b ,  t ,  n ,  f ,  r ,  “ ,   ,  \ ,  0 ,  1 ,  2 ,  3 ,  4 ,  5 ,  6 , or  7)进行转义而引进的新的转义方式.</p>
<h3 id="如果在正则表达式中使用-与"><a href="#如果在正则表达式中使用-与" class="headerlink" title="如果在正则表达式中使用\与\\"></a>如果在正则表达式中使用\与\\</h3><p>对于那些只在正则表达式中有特殊含义的字符(非b ,  t ,  n ,  f ,  r ,  “ ,   ,  \ ,  0 ,  1 ,  2 ,  3 ,  4 ,  5 ,  6 , or  7) ,使用\\,如(D,s,S,w,W, +,…..)</p>
<p>对于(b ,  t ,  n ,  f ,  r ,  “ ,   ,  \ ,  0 ,  1 ,  2 ,  3 ,  4 ,  5 ,  6 , or  7), 依然使用\</p>
<p><em>注:这里有一个特殊的字符\, 如果想将之转义为普通的反斜线,并不能直接\\, 因为这和正则表达式中定义的新的转义方式冲突了,这种情况下使用\\\\,表示正则表达式中的字面意义的反斜线. 这是一种特殊情况, 记下即可</em></p>
<p><em>再注: 还有一个特殊字符b, 使用\与\\转义后的含义不同,此时应该根据所使用的含义进行选择</em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/20/arrays/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/20/arrays/" itemprop="url">Arrays常用函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-20T00:00:00+08:00">
                2016-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-将数组转换成列表"><a href="#1-将数组转换成列表" class="headerlink" title="1. 将数组转换成列表"></a>1. 将数组转换成列表</h4><pre><code>static &lt;T&gt; List&lt;T&gt; asList(T... a) 将一个数组转换成固定大小的列表
</code></pre><h4 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h4><pre><code>static int binarySearch(T[] a, T key)

static int binarySearch(T[] a, int fromIndex, int toIndex, T key)([fromIndex, toIndex))
</code></pre><p>T是基本类型或Object, 返回值为key在数组中的索引, 如果不存在, 返回值为(-(插入点)-1)</p>
<h4 id="3-复制数组"><a href="#3-复制数组" class="headerlink" title="3. 复制数组"></a>3. 复制数组</h4><pre><code>static T[] copyOf(T[] original, int newLength)
</code></pre><p>复制指定的数组，截取或用 X 填充（根据T的类型, 如T为boolean, 就用false填充），以使副本具有指定的长度。</p>
<pre><code>static T[] copyOfRange(T[] original, int from, int to)([from, to))
</code></pre><p>复制指定范围的数组</p>
<h4 id="4-比较"><a href="#4-比较" class="headerlink" title="4. 比较"></a>4. 比较</h4><p><strong>比较多维数组</strong></p>
<pre><code>static boolean deepEquals(Object[] a1, Object[] a2)
</code></pre><p>最终比较的依然是最内层数组中元素的值, 当使用基本类型时,会autoboxing</p>
<p><strong>比较一维数组</strong></p>
<pre><code>static boolean equals(T[] a1, T[] a2)
</code></pre><p>T为基本类型或Object</p>
<h4 id="5-填充数组"><a href="#5-填充数组" class="headerlink" title="5. 填充数组"></a>5. 填充数组</h4><pre><code>static void fill(T[] a, T val)

static void fill(T[] a, int fromIndex, int toIndex, T val)
</code></pre><p>T为基本类型或Object</p>
<h4 id="6-排序"><a href="#6-排序" class="headerlink" title="6. 排序"></a>6. 排序</h4><pre><code>static void sort(T[] a)

static void sort(T[] a, int fromIndex, int toIndex)

static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)

static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c)
</code></pre><p>T为基本类型或Object</p>
<p>对于基本类型,按数值的升值排序, 或使用提供的Comparator</p>
<p>对于Object, 按自然顺序(即compareTo方法)进行排序或使用提供的Comparator</p>
<h4 id="7-返回指定数组内容的字符串形式"><a href="#7-返回指定数组内容的字符串形式" class="headerlink" title="7. 返回指定数组内容的字符串形式"></a>7. 返回指定数组内容的字符串形式</h4><pre><code>static String toString(T[] a)(一维数组)

static String deepToString(Object[] a)(多维数组)
</code></pre><p>T为基本类型或Object</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/11/dispatch-and-method-invocation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/11/dispatch-and-method-invocation/" itemprop="url">分派与方法调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="这里所说的方法调用指的是什么"><a href="#这里所说的方法调用指的是什么" class="headerlink" title="这里所说的方法调用指的是什么?"></a>这里所说的方法调用指的是什么?</h3><p>这里方法调用并不是指方法的执行,而是指确定所调用的方法的版本(即调用哪一个方法),因为一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(相当于直接引用),所以在方法执行前,要在不同阶段确定其最终要使用的版本.</p>
<p>根据所调用的方法类别不同,确定所调用方法的版本有两种方法:<strong>解析</strong>与<strong>分派</strong></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>该方法针对的是那些在程序真正运行之前就可以确定调用版本的方法,并且这个方法的调用版本在运行期是不可改变的.确定这类方法的调用版本称为<strong>解析</strong>.</p>
<p>这类方法主要包括</p>
<ul>
<li>静态方法</li>
<li>私有方法</li>
<li>实例构造器</li>
<li>父类方法</li>
<li><strong>被final修饰的方法</strong></li>
</ul>
<p>确定这些方法的调用版本的时期是在<strong>类的加载</strong>阶段(不会出现在程序运行阶段). 这些方法可以称为<strong>非虚方法</strong>, 相对的,其他方法称为<strong>虚方法</strong>(除去final方法)</p>
<p>调用这几类方法的字节码指令如下:</p>
<pre><code>invokestatic:调用静态方法
invokespecial:调用实例构造器&lt;init&gt;方法,私有方法和父类方法
</code></pre><h3 id="分派-dispatch"><a href="#分派-dispatch" class="headerlink" title="分派(dispatch)"></a>分派(dispatch)</h3><p>根据变量的类型来确定调用的方法版本,称为分派.</p>
<p>分派可能是<strong>静态的</strong>, 也可能是<strong>动态的</strong>.<br>根据分派依据的宗量数可分为<strong>单分派</strong>, <strong>多分派</strong></p>
<p>由此两两组合构成了<strong>静态单分派</strong>, <strong>静态多分派</strong>, <strong>动态单分派</strong>, <strong>动态多分派</strong></p>
<p>涉及到分派的字节码指令为</p>
<pre><code>invokevirtual:调用所有虚方法
</code></pre><h4 id="1-静态分派"><a href="#1-静态分派" class="headerlink" title="1 静态分派"></a>1 静态分派</h4><p>首先了解几个概念,先看代码</p>
<p>有如下继承关系</p>
<pre><code>abstract class Human {}

class Man extends Human {}

class Woman extends Human {}
</code></pre><p>有如下代码</p>
<pre><code>Human h = new Man();
</code></pre><p>其中Human叫做变量h的<strong>静态类型</strong>, 或者叫做<strong>外观类型</strong></p>
<p>而Man叫做变量的<strong>实际类型</strong></p>
<p>有了以上概念,可得静态分派的定义</p>
<blockquote>
<p>依赖静态类型来定位方法执行版本的分派动作称为静态分派.</p>
</blockquote>
<p>静态分派的典型应用是<strong>方法重载</strong>. 如下代码所示</p>
<pre><code>public void sayHello(Human guy) {
    System.out.println(&quot;hello guy&quot;);
}

public void sayHello(Man guy) {
    System.out.println(&quot;hello gentleman&quot;);
}

public void sayHello(Woman guy) {
    System.out.println(&quot;hello lady&quot;);
}

Human h = new Man();

sayHello(h);
</code></pre><p>以上代码的输出结果为</p>
<pre><code>hello guy
</code></pre><p>可见,是根据h的静态类型来确定所调用方法的版本.</p>
<p>另外,<strong>静态分派发生在编译阶段</strong>, 并不是由虚拟机来执行的.</p>
<h4 id="2-动态分派"><a href="#2-动态分派" class="headerlink" title="2 动态分派"></a>2 动态分派</h4><p>前面了解到静态分派的典型应用是方法重载(overload), 而动态分派的典型应用是多态性的另一种体现:<strong>重写(override)</strong></p>
<p>动态分派是根据变量的<strong>实际类型</strong>来进行分派的.动态分派就是平时常用的多态性.</p>
<p>动态分派的定义如下</p>
<blockquote>
<p>在<strong>运行期</strong>根据<strong>实际类型</strong>确定方法执行版本的分派过程称为动态分派</p>
</blockquote>
<h4 id="3-单分派和多分派"><a href="#3-单分派和多分派" class="headerlink" title="3 单分派和多分派"></a>3 单分派和多分派</h4><p>首先了解一个概念<strong>宗量</strong></p>
<blockquote>
<p>方法的接收者(a.method(), a就是接收者)与方法的参数统称为方法的宗量</p>
</blockquote>
<p>单分派是根据一个宗量对方法的版本进行选择,多分派是根据多个宗量.</p>
<p>以下是一个静态分派与动态分派结合的例子</p>
<pre><code>class Fruit{}

class Apple extends Fruit{}

class Banana extends Fruit{}

class People{

    public void eat(Fruit f){
        System.out.println(&quot;People eat Fruit&quot;);
    }

    public void eat(Apple f){
        System.out.println(&quot;People eat Apple&quot;);
    }

    public void eat(Banana f){
        System.out.println(&quot;People eat Banana&quot;);
    }
}

class Boy extends People{

    public void eat(Fruit f){
        System.out.println(&quot;Boy eats Fruit&quot;);
    }
    public void eat(Apple f){
        System.out.println(&quot;Boy eats Apple&quot;);
    }
    public void eat(Banana f){
        System.out.println(&quot;Boy eats Banana&quot;);
    }
}

public static void main(String[] argu) {

    People boy = new Boy();
    Fruit apple = new Apple();
    Fruit banana = new Banana();

    boy.eat(apple);
    boy.eat(banana);
}
</code></pre><p>结果是:</p>
<pre><code>Boy eats Fruit
Boy eats Fruit
</code></pre><p><strong>虚拟机动态分派的实现</strong></p>
<p><em>以下方法只是一种常用的实现方法,并不代表唯一方法</em></p>
<p>为了实现动态分派, 会为类在方法区中建立一个虚方法表, 表中存放着各个方法的实际入口地址. 如果某个方法在子类中没有被重写,那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的,都指向父类的实现入口.如果子类重写了这个方法,子类方法表中的地址将会替换为指向子类实现版本的入口地址.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/11/reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/11/reflection/" itemprop="url">反射基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用反射的过程往往涉及两步</p>
<ol>
<li>根据”类名”来获取对应类的Class对象(每一个类都有一个Class对象)</li>
<li>通过Class对象的函数接口,来得到类的相关信息(如构造函数,成员变量,成员函数,继承关系,注解等)</li>
</ol>
<h2 id="1-如何得到Class对象"><a href="#1-如何得到Class对象" class="headerlink" title="1. 如何得到Class对象"></a>1. 如何得到Class对象</h2><p>有3种方法</p>
<ol>
<li>Class.forName(“类名字符串”) （注意：类名字符串必须是全称，包名+类名）</li>
<li>类名.class</li>
<li>实例对象.getClass()</li>
</ol>
<h2 id="2-使用Class对象"><a href="#2-使用Class对象" class="headerlink" title="2. 使用Class对象"></a>2. 使用Class对象</h2><p>Class对象的接口如下</p>
<pre><code>public static Class    forName(String className)
public static Class    forName(String name, boolean initialize, ClassLoader     loader)
public Constructor    getConstructor(Class[] parameterTypes)
public Constructor[]    getConstructors()
public Constructor    getDeclaredConstructor(Class[] parameterTypes)
public Constructor[]    getDeclaredConstructors()
public Constructor    getEnclosingConstructor()
public Method    getMethod(String name, Class[] parameterTypes)
public Method[]    getMethods()
public Method    getDeclaredMethod(String name, Class[] parameterTypes)
public Method[]    getDeclaredMethods()
public Method    getEnclosingMethod()
public Field    getField(String name)
public Field[]    getFields()
public Field    getDeclaredField(String name)
public Field[]    getDeclaredFields()
public Type[]    getGenericInterfaces()
public Type    getGenericSuperclass()
public Annotation&lt;A&gt;    getAnnotation(Class annotationClass)
public Annotation[]    getAnnotations()
public Annotation[]    getDeclaredAnnotations()
public boolean    isAnnotation()
public boolean    isAnnotationPresent(Class annotationClass)
public boolean    isAnonymousClass()
public boolean    isArray()
public boolean    isAssignableFrom(Class cls)
public boolean    desiredAssertionStatus()
public Class&lt;U&gt;    asSubclass(Class clazz)
public Class    getSuperclass()
public Class    getComponentType()
public Class    getDeclaringClass()
public Class    getEnclosingClass()
public Class[]    getClasses()
public Class[]    getDeclaredClasses()
public Class[]    getInterfaces()
public boolean    isEnum()
public boolean    isInstance(Object obj)
public boolean    isInterface()
public boolean    isLocalClass()
public boolean    isMemberClass()
public boolean    isPrimitive()
public boolean    isSynthetic()
public String    getSimpleName()
public String    getName()
public String    getCanonicalName()
public String    toString()
public ClassLoader    getClassLoader()
public Package    getPackage()
public int    getModifiers()
public ProtectionDomain    getProtectionDomain()
public URL    getResource(String name)
public InputStream    getResourceAsStream(String name)
public Object    cast(Object obj)
public Object    newInstance()
public Object[]    getSigners()
public Object[]    getEnumConstants()
public TypeVariable[]    getTypeParameters()
</code></pre><p>虽然很多,但是可以分为四类:</p>
<ol>
<li>构造函数相关</li>
<li>成员方法相关</li>
<li>成员变量相关</li>
<li>类的其它信息(如注解、包名、类名、继承关系等等).</li>
</ol>
<h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><pre><code>//以下得到的构造函数都是该类本身所声明的,不包括父类的构造函数, 不带Declared的版本只返回public, 带Declared的版本返回所有
// 获取“参数是parameterTypes”的public的构造函数
public Constructor getConstructor(Class[] parameterTypes)

// 获取全部的public的构造函数
public Constructor[] getConstructors()

// 获取“参数是parameterTypes”的，并且是类自身声明的构造函数，包含public、protected和private方法。
public Constructor getDeclaredConstructor(Class[] parameterTypes)

// 获取类自身声明的全部的构造函数，包含public、protected和private方法。
public Constructor[] getDeclaredConstructors()
</code></pre><p>其中<strong>Constructor</strong>代表了构造函数,通过其<strong>newInstance()</strong>方法可以生成类的实例</p>
<h3 id="2-2-成员方法"><a href="#2-2-成员方法" class="headerlink" title="2.2 成员方法"></a>2.2 成员方法</h3><pre><code>// 获取“名称是name，参数是parameterTypes”的public的函数(包括从基类继承的、从接口实现的所有public函数)
public Method getMethod(String name, Class[] parameterTypes)

// 获取全部的public的函数(包括从基类继承的、从接口实现的所有public函数)
public Method[] getMethods()

// 获取“名称是name，参数是parameterTypes”，并且是类自身声明的函数，包含public,protected和private方法。
public Method getDeclaredMethod(String name, Class[] parameterTypes)

// 获取全部的类自身声明的函数，包含public、protected和private方法。
public Method[] getDeclaredMethods()
</code></pre><p>其中<strong>Method</strong>代表了构造函数,通过其<strong>invoke()</strong>方法可以调用该方法, 通过<strong>setAccessible()</strong>可改变其访问性</p>
<h3 id="2-3-成员变量"><a href="#2-3-成员变量" class="headerlink" title="2.3 成员变量"></a>2.3 成员变量</h3><pre><code>// 获取“名称是name”的public的成员变量(包括从基类继承的、从接口实现的所有public成员变量)
public Field getField(String name)

// 获取全部的public成员变量(包括从基类继承的、从接口实现的所有public成员变量)
public Field[] getFields()

// 获取“名称是name”，并且是类自身声明的成员变量，包含public、protected和private    成员变量。
public Field getDeclaredField(String name)

// 获取全部的类自身声明的成员变量，包含public、protected和private成员变量。
public Field[] getDeclaredFields()
</code></pre><p>其中<strong>Field</strong>代表域,调用其<strong>set</strong>, <strong>get</strong>可改变其值,通过<strong>setAccessible()</strong>可改变其访问性.</p>
<h3 id="2-4-类的其它信息"><a href="#2-4-类的其它信息" class="headerlink" title="2.4 类的其它信息"></a>2.4 类的其它信息</h3><h4 id="2-4-1-“注解”相关API"><a href="#2-4-1-“注解”相关API" class="headerlink" title="2.4.1 “注解”相关API"></a>2.4.1 “注解”相关API</h4><pre><code>// 获取类的&quot;annotationClass&quot;类型的注解 (包括从基类继承的、从接口实现的所有public成员变量)
public Annotation&lt;A&gt; etAnnotation(Class annotationClass)

// 获取类的全部注解 (包括从基类继承的、从接口实现的所有public成员变量)
public Annotation[] getAnnotations()

// 获取类自身声明的全部注解 (包含public、protected和private成员变量)
public Annotation[] getDeclaredAnnotations()
</code></pre><h4 id="2-4-2-“父类”和“接口”相关的API"><a href="#2-4-2-“父类”和“接口”相关的API" class="headerlink" title="2.4.2 “父类”和“接口”相关的API"></a>2.4.2 “父类”和“接口”相关的API</h4><pre><code>// 获取实现的全部接口
public Type[] getGenericInterfaces()

// 获取父类
public Type getGenericSuperclass()
</code></pre><h4 id="2-4-3-其它API"><a href="#2-4-3-其它API" class="headerlink" title="2.4.3 其它API"></a>2.4.3 其它API</h4><pre><code>// 获取“类名”
public String getSimpleName()

// 获取“完整类名”
public String getName()

// 类是不是“枚举类”
public boolean isEnum()

// obj是不是类的对象
public boolean isInstance(Object obj)

// 类是不是“接口”
public boolean isInterface()

// 类是不是“本地类”。本地类,就是定义在方法内部的类。
public boolean isLocalClass()

// 类是不是“成员类”。成员类,是内部类的一种，但是它不是“内部类”或“匿名类”。
public boolean isMemberClass()

// 类是不是“基本类型”。     基本类型，包括void和boolean、byte、char、short、int、long、float 和     double这几种类型。
public boolean isPrimitive()

// 类是不是“复合类”。 JVM中才会产生复合类，在java应用程序中不存在“复合类”！
public boolean isSynthetic()
</code></pre><h2 id="3-关于Declared"><a href="#3-关于Declared" class="headerlink" title="3. 关于Declared"></a>3. 关于Declared</h2><p>getConstructors(), getMethods(), getFields()都有其Declared的版本, 这两种版本的区别是什么呢?</p>
<p>其中不带Declared的版本, 是得到该类的所有public成员(包括从父类继承的), 因为Constructor不能从父类继承, 所以getConstructors()只是返回当前类的public构造函数</p>
<p>而带Declared的版本返回当前类中所声明的所有的成员(不包括从父类继承, 但是包括public, private, protected)</p>
<h2 id="4-关于以上API的例子-请参考如下文章"><a href="#4-关于以上API的例子-请参考如下文章" class="headerlink" title="4. 关于以上API的例子,请参考如下文章"></a>4. 关于以上API的例子,请参考如下文章</h2><p><a href="http://wangkuiwu.github.io/2012/03/04/reflection/" target="_blank" rel="noopener">Java 反射机制(包括组成、结构、示例说明等内容)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/11/equals-hashcode-tostring-clone-finalize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/11/equals-hashcode-tostring-clone-finalize/" itemprop="url">equals hashCode clone </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Object主要是用来扩展的,它定义了一些非final方法,如</p>
<p>equals, hashCode, clone</p>
<p>这些方法交有子类实现,但实现并非随意,Object为这些方法的实现设定了一些约定,子类的实现必须遵守这些约定.</p>
<p><strong>为什么需要遵守这些约定呢?</strong></p>
<blockquote>
<p>因为Java类库的类已经遵守了这些约定,如果自定义的类不遵守这些约定的话,那么,自定义的类就不能和类库中的类正常的工作.</p>
</blockquote>
<p>以下从两个方面对各个方法进行介绍</p>
<ol>
<li>需要遵守哪些约定?</li>
<li>如何遵守约定(即如何正确的编写这些方法)</li>
</ol>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><h4 id="什么时候需要覆盖equals"><a href="#什么时候需要覆盖equals" class="headerlink" title="什么时候需要覆盖equals"></a>什么时候需要覆盖equals</h4><p>通常需要覆盖equals是一种”值类”, 对于这种类的对象a, b,并不关心是否是同一个对象,而是关于它的值是不是相同的,如Integer和Date</p>
<h4 id="需要遵守的约定"><a href="#需要遵守的约定" class="headerlink" title="需要遵守的约定"></a>需要遵守的约定</h4><ol>
<li>自反性</li>
<li>对称性</li>
<li>传递性</li>
<li>一致性</li>
<li>对于任何非null的引用值x, x.equals(null)返回false</li>
</ol>
<p>值得注意的是, 试图去比较一个添加了新的值组件(即一个新的域,该域对该对象的值有影响)与其父类对象是很困难的,这往往导致违反对称性与传递性的约定. 一种workaround就是<strong>复合优于继承</strong></p>
<p>关于以上的详细解释,参照<em>Effective Java</em>第8条.</p>
<h4 id="如何编写equals方法"><a href="#如何编写equals方法" class="headerlink" title="如何编写equals方法"></a>如何编写equals方法</h4><ol>
<li>使用==操作符检查”参数是否为这个对象的引用”</li>
<li>使用instanceof操作符检查”参数是否是正确的类型”</li>
<li>把参数转换成正确的类型</li>
<li>对于该类中的每个”关键(significant,对其值有影响)”域, 检查参数中的域是否与该对象中对应的域相匹配</li>
</ol>
<p>一个例子</p>
<pre><code>class PhoneNumber {

    private short areaCode;
    private short prefix;
    private short lineNumber;

    public boolean equals(Object o) {
        if (o == this)
            return true;

        if (!(o instanceof PhoneNumber))
            return false;

        PhoneNumber pn = (PhoneNumber)o;

        return pn.areaCode == areaCode &amp;&amp; pn.prefix == prefix &amp;&amp; pn.lineNumber == lineNumber;
    }
}
</code></pre><p> 更详细的解释请参照<em>Effective Java</em>第8条.</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><blockquote>
<p>覆盖equals时总要覆盖hashCode</p>
</blockquote>
<p>为什么?</p>
<p>不妨从反面去考虑一下</p>
<blockquote>
<p>如果只覆盖equals而不覆盖hashCode， 会发生什么？</p>
</blockquote>
<p>比如说对以下场景， 如果我们覆盖了PhoneNumber的equals方法， 认为电话号码相同的两个对象是相同的。那么对于如下代码。</p>
<pre><code>class PhoneNumber {}

Map&lt;PhoneNumber, String&gt; m = new HashMap&lt;PhoneNumber, String&gt;();
m.put(new PhoneNumber(&quot;1862233445&quot;), ht);

String name = m.get(new PhoneNumber(&quot;1862233445&quot;));
</code></pre><p>如果两者的hashCode不同， 则会放在不同的bucket中， 于是name就为空, 这对使用者来说， 很困惑。</p>
<p>所以覆盖equals后也就覆盖hashCode.</p>
<p><strong>所以可知,当期望两个对象通过equals比较相同时,也同时希望它们的hashCode返回相同的整形值.并可以推论出,equals与hashCode方法中涉及到的域也应该是相同的,并且都是与”值”有关的域.</strong></p>
<p><strong>同时也可以推导出,如果一个域对该对象的”值”没有影响,则不应该影响到equals与hashCode的结果</strong></p>
<p>上面的讨论只是说明了</p>
<p><strong>如果对象相等, 那么hashCode返回相同的整型值</strong></p>
<p>其它情况都是允许的,并没有规定,如hashCode返回相同整形值,对象不相等.</p>
<h4 id="如何编写hashCode方法"><a href="#如何编写hashCode方法" class="headerlink" title="如何编写hashCode方法"></a>如何编写hashCode方法</h4><p>参照<em>Effective Java</em>第9条.</p>
<h3 id="clone方法与深拷贝与浅拷贝"><a href="#clone方法与深拷贝与浅拷贝" class="headerlink" title="clone方法与深拷贝与浅拷贝"></a>clone方法与深拷贝与浅拷贝</h3><ol>
<li>Object的clone方法是一个native方法</li>
<li><p>一个对象要想提供一个public的clone方法， 就必须实现cloneable接口， 这是因为Object.clone()会返回一个实现了Cloneable接口的对象的逐域拷贝， 如果没有实现cloneable接口， 在调用Object.clone()时会抛出CloneNotSupportedException的异常</p>
<p>一般clone方法是这样的</p>
<p>   @override<br>   public SubClass clone() {</p>
<pre><code>try {
    retrun (SubClass) super.clone();
} catch(CloneNotSupportedException e) {...}
</code></pre><p>   }</p>
</li>
<li><p>clone是浅拷贝，所以需要人工的去重置各个域指向新的成员对象。</p>
</li>
<li>在一个调用链中， 需要所有的父类实现深拷贝的clone()，但有时这是不可能的， 因为父类可能来自第三方库</li>
<li><p>所以， 如果想实现拷贝的功能， 最好是不用clone()， 而是提供一个copy constructor或copy factory， 就像这样</p>
<pre><code>public Yum(Yum objectToBeClone)

public static Yum newInstance(Yum objectToBeClone)
</code></pre></li>
</ol>
<p>参考</p>
<p><a href="http://blog.csdn.net/zhangjg_blog/article/details/18369201" target="_blank" rel="noopener">详解Java中的clone方法 – 原型模式</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">asanelder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lingnanlu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/lingnanlu" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">asanelder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
