<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="keywords" content="Code, Food, Music">
<meta property="og:type" content="website">
<meta property="og:title" content="Code, Food &amp; Music">
<meta property="og:url" content="http://asanelder.me/page/9/index.html">
<meta property="og:site_name" content="Code, Food &amp; Music">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Code, Food &amp; Music">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://asanelder.me/page/9/">





  <title>Code, Food & Music</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Code, Food & Music</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/11/dispatch-and-method-invocation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/11/dispatch-and-method-invocation/" itemprop="url">分派与方法调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="这里所说的方法调用指的是什么"><a href="#这里所说的方法调用指的是什么" class="headerlink" title="这里所说的方法调用指的是什么?"></a>这里所说的方法调用指的是什么?</h3><p>这里方法调用并不是指方法的执行,而是指确定所调用的方法的版本(即调用哪一个方法),因为一切方法调用在Class文件里面存储的都只是符号引用,而不是方法在实际运行时内存布局中的入口地址(相当于直接引用),所以在方法执行前,要在不同阶段确定其最终要使用的版本.</p>
<p>根据所调用的方法类别不同,确定所调用方法的版本有两种方法:<strong>解析</strong>与<strong>分派</strong></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>该方法针对的是那些在程序真正运行之前就可以确定调用版本的方法,并且这个方法的调用版本在运行期是不可改变的.确定这类方法的调用版本称为<strong>解析</strong>.</p>
<p>这类方法主要包括</p>
<ul>
<li>静态方法</li>
<li>私有方法</li>
<li>实例构造器</li>
<li>父类方法</li>
<li><strong>被final修饰的方法</strong></li>
</ul>
<p>确定这些方法的调用版本的时期是在<strong>类的加载</strong>阶段(不会出现在程序运行阶段). 这些方法可以称为<strong>非虚方法</strong>, 相对的,其他方法称为<strong>虚方法</strong>(除去final方法)</p>
<p>调用这几类方法的字节码指令如下:</p>
<pre><code>invokestatic:调用静态方法
invokespecial:调用实例构造器&lt;init&gt;方法,私有方法和父类方法
</code></pre><h3 id="分派-dispatch"><a href="#分派-dispatch" class="headerlink" title="分派(dispatch)"></a>分派(dispatch)</h3><p>根据变量的类型来确定调用的方法版本,称为分派.</p>
<p>分派可能是<strong>静态的</strong>, 也可能是<strong>动态的</strong>.<br>根据分派依据的宗量数可分为<strong>单分派</strong>, <strong>多分派</strong></p>
<p>由此两两组合构成了<strong>静态单分派</strong>, <strong>静态多分派</strong>, <strong>动态单分派</strong>, <strong>动态多分派</strong></p>
<p>涉及到分派的字节码指令为</p>
<pre><code>invokevirtual:调用所有虚方法
</code></pre><h4 id="1-静态分派"><a href="#1-静态分派" class="headerlink" title="1 静态分派"></a>1 静态分派</h4><p>首先了解几个概念,先看代码</p>
<p>有如下继承关系</p>
<pre><code>abstract class Human {}

class Man extends Human {}

class Woman extends Human {}
</code></pre><p>有如下代码</p>
<pre><code>Human h = new Man();
</code></pre><p>其中Human叫做变量h的<strong>静态类型</strong>, 或者叫做<strong>外观类型</strong></p>
<p>而Man叫做变量的<strong>实际类型</strong></p>
<p>有了以上概念,可得静态分派的定义</p>
<blockquote>
<p>依赖静态类型来定位方法执行版本的分派动作称为静态分派.</p>
</blockquote>
<p>静态分派的典型应用是<strong>方法重载</strong>. 如下代码所示</p>
<pre><code>public void sayHello(Human guy) {
    System.out.println(&quot;hello guy&quot;);
}

public void sayHello(Man guy) {
    System.out.println(&quot;hello gentleman&quot;);
}

public void sayHello(Woman guy) {
    System.out.println(&quot;hello lady&quot;);
}

Human h = new Man();

sayHello(h);
</code></pre><p>以上代码的输出结果为</p>
<pre><code>hello guy
</code></pre><p>可见,是根据h的静态类型来确定所调用方法的版本.</p>
<p>另外,<strong>静态分派发生在编译阶段</strong>, 并不是由虚拟机来执行的.</p>
<h4 id="2-动态分派"><a href="#2-动态分派" class="headerlink" title="2 动态分派"></a>2 动态分派</h4><p>前面了解到静态分派的典型应用是方法重载(overload), 而动态分派的典型应用是多态性的另一种体现:<strong>重写(override)</strong></p>
<p>动态分派是根据变量的<strong>实际类型</strong>来进行分派的.动态分派就是平时常用的多态性.</p>
<p>动态分派的定义如下</p>
<blockquote>
<p>在<strong>运行期</strong>根据<strong>实际类型</strong>确定方法执行版本的分派过程称为动态分派</p>
</blockquote>
<h4 id="3-单分派和多分派"><a href="#3-单分派和多分派" class="headerlink" title="3 单分派和多分派"></a>3 单分派和多分派</h4><p>首先了解一个概念<strong>宗量</strong></p>
<blockquote>
<p>方法的接收者(a.method(), a就是接收者)与方法的参数统称为方法的宗量</p>
</blockquote>
<p>单分派是根据一个宗量对方法的版本进行选择,多分派是根据多个宗量.</p>
<p>以下是一个静态分派与动态分派结合的例子</p>
<pre><code>class Fruit{}

class Apple extends Fruit{}

class Banana extends Fruit{}

class People{

    public void eat(Fruit f){
        System.out.println(&quot;People eat Fruit&quot;);
    }

    public void eat(Apple f){
        System.out.println(&quot;People eat Apple&quot;);
    }

    public void eat(Banana f){
        System.out.println(&quot;People eat Banana&quot;);
    }
}

class Boy extends People{

    public void eat(Fruit f){
        System.out.println(&quot;Boy eats Fruit&quot;);
    }
    public void eat(Apple f){
        System.out.println(&quot;Boy eats Apple&quot;);
    }
    public void eat(Banana f){
        System.out.println(&quot;Boy eats Banana&quot;);
    }
}

public static void main(String[] argu) {

    People boy = new Boy();
    Fruit apple = new Apple();
    Fruit banana = new Banana();

    boy.eat(apple);
    boy.eat(banana);
}
</code></pre><p>结果是:</p>
<pre><code>Boy eats Fruit
Boy eats Fruit
</code></pre><p><strong>虚拟机动态分派的实现</strong></p>
<p><em>以下方法只是一种常用的实现方法,并不代表唯一方法</em></p>
<p>为了实现动态分派, 会为类在方法区中建立一个虚方法表, 表中存放着各个方法的实际入口地址. 如果某个方法在子类中没有被重写,那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的,都指向父类的实现入口.如果子类重写了这个方法,子类方法表中的地址将会替换为指向子类实现版本的入口地址.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/11/java-sugar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/11/java-sugar/" itemprop="url">Java中的语法糖</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是语法糖"><a href="#什么是语法糖" class="headerlink" title="什么是语法糖"></a>什么是语法糖</h3><p><strong>语法糖并没有为语言添加新的功能</strong>,其存在只是为了方便程序员编写代码,提升效率,减少编写代码中出错的机会等.</p>
<h3 id="Java中的语法糖包括如下"><a href="#Java中的语法糖包括如下" class="headerlink" title="Java中的语法糖包括如下"></a>Java中的语法糖包括如下</h3><h4 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1 泛型"></a>1 泛型</h4><p>Java中的泛型是伪泛型, 其含义是泛型信息只包含在源码中,在编译后的字节码中,并不存在泛型信息.</p>
<p>因为泛型也是一种语法糖,所以其所实现的功能也是可以不使用泛型来实现的,在该语法糖出现以前,是利用Object与向下转型实现相同的功能.</p>
<p>对于泛型,解开语法糖后是如下这种形式</p>
<pre><code>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
map.put(&quot;hello&quot;, &quot;nihao&quot;);
System.out.println(map.get(&quot;hello&quot;));
</code></pre><p>会转化为</p>
<pre><code>Map map = new HashMap();
map.put(&quot;hello&quot;, &quot;nihao&quot;);
System.out.println((String) map.get(&quot;hello&quot;));
</code></pre><p>可见其在使用其内容时,会对其进行向下转型.</p>
<p><em>泛型中的常用符号及含义</em></p>
<p>见<a href="http://lingnanlu.github.io/2016/03/10/right-use-of-java-generics-wildcards" target="_blank" rel="noopener">正确理解通配符的使用</a></p>
<h4 id="2-自动装箱-自动拆箱"><a href="#2-自动装箱-自动拆箱" class="headerlink" title="2 自动装箱/自动拆箱"></a>2 自动装箱/自动拆箱</h4><p>自动装箱/自动拆箱是对基本类型的包装</p>
<p><strong>发生的时机</strong></p>
<p>当该使用包装类时,使用了基本类型,则发生自动装箱<br>当该使用基本类型时,使用了包装类型,则发生自动拆箱</p>
<p>所谓自动装箱和自动拆箱就是如下这样的语法糖</p>
<pre><code>Integer i = 1;
</code></pre><p>转化为</p>
<pre><code>Integer i = Integer.valueOf(1);

int j = i;
</code></pre><p>转化为</p>
<pre><code>int j = i.intValue();
</code></pre><p><strong>生成Integer对象</strong></p>
<p>因为<code>Integer a = i</code>会转化为<code>Integer a = Integer.valueOf(1)</code>, 查看<code>valueOf(int)</code>的代码为</p>
<pre><code>if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
    return IntegerCache.cache[i + (-IntegerCache.low)];
return new Integer(i);
</code></pre><p>可见, 当i为某一范围时(默认为-127~128), 生成的对象从缓冲池中获取, 当不在这个范围时, 会生成新的对象, 所以有如下情况</p>
<pre><code>Integer a = 1;
Integer b = 1;
System.out.println(a == b) //true

Integer a = 200;
Integer b = 200;
System.out.println(a == b) //false

Integer a = 3;
Integer b = new Integer(3);
System.out.println(a == b) //false
</code></pre><p>注意对于<strong>多个</strong>包装类的==运算,当不遇到算术运算时并不会自动拆箱,而有算术运算时会自动拆箱,如以下两种情况</p>
<pre><code>Integer a = 1;
Integer b = 2;
Integer c = 3;

System.out.println(a == b); //不会自动拆箱
System.out.println(c == (a + b)); //会自动拆箱
</code></pre><h4 id="3-Foreach循环"><a href="#3-Foreach循环" class="headerlink" title="3 Foreach循环"></a>3 Foreach循环</h4><pre><code>List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4);

int sum = 0;
for(int i : list) {
    sum += i;
}
</code></pre><p>会转化成</p>
<pre><code>for(Iterator it = list.iterator(); it.hasNext();) {
    int i = ((Integer)it.next()).intValue();
    sum += i;
}
</code></pre><p>所以,要想使用Foreach循环,必须实现Iterable接口</p>
<h4 id="4-变长参数"><a href="#4-变长参数" class="headerlink" title="4 变长参数"></a>4 变长参数</h4><p>变长参数实际上会被转化成数组, 如</p>
<pre><code>method(T... a);
</code></pre><p>转化成</p>
<pre><code>method(new T[]);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/10/right-use-of-java-generics-wildcards/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/10/right-use-of-java-generics-wildcards/" itemprop="url">Java通配符的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-10T00:00:00+08:00">
                2016-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="错误的使用通配符"><a href="#错误的使用通配符" class="headerlink" title="错误的使用通配符"></a>错误的使用通配符</h3><p>首先先举出一种错误的用法.</p>
<p>下面文章中提到了两个例子,然后解释了例子编译错误的原因.而实际上其举例子就是对通配符的错误理解和使用.</p>
<p><a href="http://peiquan.blog.51cto.com/7518552/1303768" target="_blank" rel="noopener">java 通配符解惑</a></p>
<p>代码中所用到的继承层次如下:</p>
<pre><code>public class Animal {}
public class Cat extends Animal {}
public class Bird extends Animal {}
public class Magpie extends Bird {}
</code></pre><p>测试代码一(\&lt;? extends Animal>):</p>
<pre><code>List&lt;? extends Animal&gt; list = new ArrayList&lt;Animal&gt;();

list.add(new Animal());    //错误
list.add(new Bird()); //错误
list.add(new Cat()); //错误

for(Animal animal : list) {
    //对每个animal进行操作
}
</code></pre><p>上面的add操作会导致编译错误,为什么呢?</p>
<p>因为list可能指向的实际对象是<code>new ArrayList&lt;Cat&gt;()</code>,所以往里<code>add(new Animal())</code>或<code>add(new Bird())</code>时,都是错误的,因为不知道list真正指向的实际对象,所以任何add都是违法的.</p>
<p>测试代码二(\&lt;? super Animal>)</p>
<pre><code>List&lt;? super Bird&gt; list = new ArrayList&lt;Animal&gt;();

list.add(new Bird(&quot;bird&quot;));
list.add(new Magpie(&quot;magpie&quot;));
list.add(new Animal(&quot;animal&quot;)); //错误
</code></pre><p>上面第一个与第二个add可以编译通过,而第三个却无法编译通过,为什么呢?</p>
<p>因为list指向的实际容器中的元素只可能是Bird的父类,往该容器中添加Bird的子类是没问题的,因为在该实际容器中的元素都可以当做Bird使用,而添加父类却不可以,因为不知道list真正指向的实际对象中保存的是Bird的哪一个父类,所以添加父类会导致类型的不匹配.如</p>
<pre><code>List&lt;? super Magpie&gt; list = new ArrayList&lt;Bird&gt;();
list.add(new Animal()); //错误
</code></pre><p>实际上,无论是测试代码一与测试代码二,虽然指出了其语法上错误的原因,但依然存在<strong>语意上的错误</strong>, 什么是<strong>语意上的错误? 就是指使用错误的技术来实现所想到表达的编程意图,换句话说,就是没理解某一技术的含义,将之用在了错误的地方.</strong>具体到这里就是,<strong>没有理解通配符的真正作用,将之用错了</strong>.</p>
<p>即然使用通配符是对其的误用,那么我们来看为了实现程序的意图,正确的用法是什么.</p>
<h4 id="代码的意图"><a href="#代码的意图" class="headerlink" title="代码的意图"></a>代码的意图</h4><p>首先看测试代码一.</p>
<p>由代码可知,其意图如下:</p>
<blockquote>
<p>创建一个容器,可以保存某一类型及其子类,并且当遍历该容器时,将其元素当做继承层次的顶层来使用.</p>
</blockquote>
<p>而表达其意图的正确代码其实很简单,不必使用通配符</p>
<pre><code>List&lt;Animal&gt; list = new ArrayList&lt;Animal&gt;();

list.add(new Animal());
list.add(new Bird());
list.add(new Cat());

for(Animal animal : list) {
    //对每个animal进行操作
}
</code></pre><p>以上代码完全没问题,简洁,干净</p>
<p>再看测试代码二.</p>
<p>其意图如何?</p>
<blockquote>
<p>创建一个容器,可以保存某一类型及其父类,并且当遍历该容器时,….</p>
</blockquote>
<p><strong>当遍历容器时怎么样? 保存某一类型的父类是为了什么? 为了将其中的元素当做子类来使用吗? 这符合多态的思想吗? 我们知道多态是将子类当做父类,而将父类当子类的想法,你在编程中见过吗?</strong></p>
<p>所以说,其实这段代码没什么意图,唯一的意图估计就是钻牛角尖吧.</p>
<h3 id="通配符的正确使用"><a href="#通配符的正确使用" class="headerlink" title="通配符的正确使用"></a>通配符的正确使用</h3><p>好了,上面说的通配符的错误使用,那么通配符的正确使用是什么呢? 在什么情况下才需要通配符呢?</p>
<p>而正是从其字面意义,才能了解到通配符的使用场景.</p>
<p><strong>其实这里的通配符的作用与Linux中,正则表达式中,搜索查找中的概念是一致的. 都是为了匹配某一模式.仅此而已.</strong></p>
<p>可通过使用通配符，一般可以扩大方法的适用范围。下面举几个例子</p>
<p><strong>简单情况</strong></p>
<p><code>List&lt;? extends Animal&gt;</code> :这是一个通配符,和它匹配的有哪些呢?如List\&lt;Animal>, List\&lt;Bird>, List\&lt;Cat>(当然,使用时,还得使用具体容器,如ArrayList)</p>
<p><code>List&lt;? super Magpie&gt;</code>: 和它匹配的有, List\&lt;Magpie>, List\&lt;Bird>, List\&lt;Animal></p>
<p>以上两个是简单的情况,下面来几个复杂的.</p>
<p><strong>复杂情况一</strong></p>
<pre><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) {...}
</code></pre><p>该方法是Collections的一个方法， 用来将多个T元素添加到Collection中。假如说,T取Bird,那么与第一个参数匹配的就是<code>Collection&lt;? super Bird&gt;</code>, 即可以是</p>
<ul>
<li>List<animal> </animal></li>
<li>List<bird></bird></li>
</ul>
<p>等等， 而将Bird放入装有Animal的容器中， 也是合情合理的。</p>
<p>这里考虑一下,如果不使用通配符,会有什么不同</p>
<pre><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) {...}
</code></pre><p>假如说,T取Bird,那么与第一个参数匹配的就只能是<code>Collection&lt;Bird&gt;</code>,所以限制了其参数的选择范围,也就是该函数的应用范围减弱了.</p>
<p><strong>复杂情况二</strong></p>
<pre><code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(Collection&lt;T&gt; coll)
</code></pre><p>Comparable中类型参数的含义是,可以与之比较的类型,这里使用了通配符, 这里的含义是说, 该函数接收一个T类型,该类型继承了一个实现了其Comparable接口的类型, 如下面这个例子</p>
<p>java中有如下继承</p>
<pre><code>class java.util.Date implements Comparable&lt;java.util.Date&gt;
class java.sql.Date extends java.util.Date
</code></pre><p>而如果一个方法是</p>
<pre><code>public static &lt;T extends Comparable&lt;T&gt;&gt; T max(Collection&lt;T&gt; coll)
</code></pre><p>则只能转入java.util.Date, 因为java.sql.Date并没有实现Comparable&lt;java.sql.Date&gt;</p>
<p>而以下方法就可以</p>
<pre><code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(Collection&lt;T&gt; coll)
</code></pre><p>另一个使用&lt;? super T&gt;的地方就是</p>
<pre><code>Arrays.sort(T[] a, Comparator&lt;? super T&gt;)
</code></pre><p>综上所述,<strong>通配符扩大了方法的适用性范围</strong>,使其从只能接收单一类型扩大到接收符合某一匹配规则的模型,这就是<strong>通配符的正确使用</strong>.</p>
<p>关于以上例子的详细解释,参见下面的文章</p>
<p><a href="http://docs.oracle.com/javase/tutorial/extra/generics/morefun.html" target="_blank" rel="noopener">More Fun with Wildcards</a></p>
<p>对于通配符的使用,要区分以上所说的误用和正确使用的情况,要想对其灵活使用,还需要大量的应用与练习,从实践中总结出其场景.</p>
<p>补充:</p>
<ol>
<li><p>通配符不能生成对象,因为从概念上说,通配符是抽象的,如下面代码是错误的.</p>
<pre><code>List&lt;? extends A&gt; list = new List&lt;? extends A&gt;();
</code></pre></li>
<li><p>List&lt;?&gt; 只是List&lt;? extends Object&gt;的简写</p>
</li>
<li><p>泛型中不使用通配符还有一种情况， 如</p>
<p>public static <t extends animal> void foobar(List<t> animals)</t></t></p>
<p>该方法只能作用在装有Animal的子类的List中， 如</p>
<ul>
<li>List<animal></animal></li>
<li>List<bird></bird></li>
</ul>
<p>如果是以下这样</p>
<p>public static <t> void foobar(List<t> animals)</t></t></p>
<p>则可以作用在装有任意类型的List中，而如果是以下这样</p>
<p>public static void foobar(List<animal> animals)</animal></p>
<p>则只能作用在装有Animal的List中</p>
</li>
</ol>
<h3 id="PECS原则producer-extends-consumer-super"><a href="#PECS原则producer-extends-consumer-super" class="headerlink" title="PECS原则producer-extends, consumer-super"></a>PECS原则producer-extends, consumer-super</h3><p>这句话的含义是, 如果参数化类型表示一个T生产者, 就使用&lt;? extends T&gt;, 如果表示一个T消费者, 就使用&lt;? super T&gt;.</p>
<p>在容器上下文环境中, 生产者指的是, 容器作为生产者， 生产对象， 即对容器的使用是从中取对象。 消费者指的是, 容器作为消费者， 消费对象， 即对容器的使用是向容器中存放对象.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/04/singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/04/singleton/" itemprop="url">Singleton从简单到完善</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-04T00:00:00+08:00">
                2016-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下是一步一步写出完善的单例过程</p>
<h3 id="1-最简单的情况"><a href="#1-最简单的情况" class="headerlink" title="1. 最简单的情况"></a>1. 最简单的情况</h3><pre><code>public final class Foo {

    private Foo instance = null;

    private Foo() {}

    public static Foo getInstance() {

        if (instance == null) {
            instance = new Foo();
        }
        return instance;
    }
}
</code></pre><p><strong>存在的问题</strong></p>
<ol>
<li>非线程安全</li>
<li><p>可以利用反射机制得到多个实例, 如下代码</p>
<pre><code>Foo first = Foo.getInstance();

Class c = Class.forName(&quot;Foo&quot;);
Constructor c = c.getDeclaredConstructor();
c.setAccessible(true);
Foo second = c.newInstance();

System.out.println(first);
System.out.println(second);
</code></pre></li>
</ol>
<h3 id="2-加上线程安全与阻止反射调用私有的构造函数"><a href="#2-加上线程安全与阻止反射调用私有的构造函数" class="headerlink" title="2. 加上线程安全与阻止反射调用私有的构造函数"></a>2. 加上线程安全与阻止反射调用私有的构造函数</h3><pre><code>public final class Foo {

    private Foo instance = null;

    private Foo() {
        if (instance != null) {
            throw new IllegalStateException(&quot;Already instantiated&quot;);
        }
    }

    public static Foo getInstance() {
        synchronized(Foo.class) {
            if (instance == null) {
                instance = new Foo();
            }
        }
        return instance;
    }
}
</code></pre><p><strong>存在的问题</strong></p>
<p>不管instance是不是Null,每次调用getInstance()都需要加锁,会带来性能问题,如果instance不为null,可以不加锁,直接返回.修改如下</p>
<pre><code>public static Foo getInstance() {

       if (instance == null){
           synchronized(Foo.class) {
               if (instance == null) {
                   instance = new Foo();
               }
        }
       }
    return instance;
}
</code></pre><h3 id="3-一种更简洁的写法-无锁写法"><a href="#3-一种更简洁的写法-无锁写法" class="headerlink" title="3. 一种更简洁的写法(无锁写法)"></a>3. 一种更简洁的写法(无锁写法)</h3><p>上面的写法有些繁琐,一种更简洁的写法如下</p>
<pre><code>public final class Foo {

    private static final Foo instance = new Foo();

    private Foo() {
        if (instance != null) {
            throw new IllegalStateException(&quot;Already instantiated&quot;);
        }
    }

    public static Foo getInstance() {
        return instance;
    }
}v
</code></pre><p>当getInstance()第一次被调用时,会导致类的初始化,从而</p>
<pre><code>private static final Foo instance = new Foo();
</code></pre><p>会被执行,生成Foo的一个实例,而且,多个线程去调用getInstance()时,类的初始化函数\&lt;clinit>()只会被调用一次,所以只有一个实例.</p>
<h3 id="4-使用lazy-initialization"><a href="#4-使用lazy-initialization" class="headerlink" title="4. 使用lazy initialization"></a>4. 使用lazy initialization</h3><p>每三种写法中,因为类初始化时,会生成Foo的实例,如果在Foo中还有其它static成员,在引用其它static成员时,依然会执行类的初始化,生成Foo的实例,即使我们此时不需要使用该类的实例.可以使用如下方法,当在真正需要使用类的实例时,才生成类的实例</p>
<pre><code>public final class Foo {

    private static class FooLoader {
        private static final Foo instance = new Foo();
    }

    private Foo() {
        if (instance != null) {
            throw new IllegalStateException(&quot;Already instantiated&quot;);
        }
    }

    public static Foo getInstance() {
        return FooLoader.instance;
    }
}
</code></pre><h3 id="5-考虑序列化"><a href="#5-考虑序列化" class="headerlink" title="5. 考虑序列化"></a>5. 考虑序列化</h3><p>类的实例不一定只能从构造函数中生成,还可能通过序列化的方式生成,以下是阻止通过序列化的方式生成类的实例</p>
<pre><code>public final class Foo implements Serializable {

    private static class FooLoader {
        private static final Foo instance = new Foo();
    }

    private Foo() {
        if (instance != null) {
            throw new IllegalStateException(&quot;Already instantiated&quot;);
        }
    }

    public static Foo getInstance() {
        return FooLoader.instance;
    }

    private Foo readResolve() {
        return FooLoader.instance;
    }
}
</code></pre><h3 id="6-一种更简洁的做法"><a href="#6-一种更简洁的做法" class="headerlink" title="6. 一种更简洁的做法"></a>6. 一种更简洁的做法</h3><pre><code>public enum Foo {
    INSTANCE;
}
</code></pre><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><ol>
<li>readResolve()是序列化中所起的作用</li>
<li>为什么<em>Effective Java</em>中要求当一个单例可序列化时,要求其所有实例域都是transient的</li>
<li>因为一个类是由class文件与类加载器唯一确定,以上只是对同一个类加载器来说,不同的类加载器对于同一个class文件都可以生成一个实例.</li>
<li>为什么Enum是一种更简洁的做法?</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://asanelder.me/2016/03/03/java-key-concepts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="asanelder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code, Food & Music">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/03/java-key-concepts/" itemprop="url">java关键概念-JMM-类加载-并发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-03T00:00:00+08:00">
                2016-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java虚拟机运行时数据区"><a href="#Java虚拟机运行时数据区" class="headerlink" title="Java虚拟机运行时数据区"></a>Java虚拟机运行时数据区</h2><p><strong>关键是熟悉该数据区分为哪几个区域以及各个区域所存放的内容.</strong></p>
<p>按是否由线程共享可分为两大类</p>
<h4 id="1-线程隔离数据区"><a href="#1-线程隔离数据区" class="headerlink" title="1.线程隔离数据区"></a>1.线程隔离数据区</h4><p>该类别中包含以下三个区域</p>
<ol>
<li><strong>程序计数器</strong></li>
<li><strong>Java虚拟机栈</strong>:每个方法执行时都会创建一个栈帧, 包括<strong>局部变量</strong>, 操作数栈, 动态链接, 方法出口. 其中最关键是<strong>局部变量</strong>, 其存放的是<strong>基本类型</strong>和<strong>引用类型</strong>.</li>
<li><strong>本地方法栈</strong>:作用与虚拟机栈类似,只是其存放的是Native方法信息.</li>
</ol>
<h4 id="2-线程共享数据区"><a href="#2-线程共享数据区" class="headerlink" title="2.线程共享数据区"></a>2.线程共享数据区</h4><ol>
<li><p><strong>Java堆</strong>: 所有的<strong>对象实例</strong>及<strong>数组</strong>(基本类型数组也是在堆上,但单个的基本类型在栈上)都是在堆上分配的. 垃圾收集器管理的主要是这个区域.</p>
<p><s>另外,在堆中可以划分出<strong>线程私有的分配缓冲区</strong>, 这应该与ThreadLocal(线程本地存储)有关</s>(这句话不正确， 暂时还不知道线程私有的分配缓冲区是什么， TODO)</p>
</li>
<li><p><strong>方法区</strong>: 包含以下</p>
<ul>
<li><strong>虚拟机加载的类信息</strong></li>
<li><strong>常量(字面量)</strong></li>
<li><strong>静态变量(static)</strong></li>
<li>编译后的代码</li>
</ul>
<p>由上可知,所谓的类的加载就是把.class文件中的信息加载到方法区中. 注意静态变量指使用static修饰的变量,而常量并非指使用final修饰的<strong>变量</strong>,而是如下代码中的5和test字面量.</p>
<pre><code>class A {
    final int a = 5;
    String b = &quot;test&quot;
}
</code></pre><p>而以上代码中的a并不是在方法区中,而是在堆中,因为对final修饰的变量,在不同实例中可能有不同的值,如以下代码</p>
<pre><code>class A {
    final int a;
    A(int a) { this.a = a; }
}
</code></pre><p>所以只用final修饰的变量并不在方法区,而是在堆中.</p>
<p>另外要注意的是,<strong>运行时常量池</strong>也是方法区的一部分,其包含的内定有两类,一类是<strong>字面量</strong>(及以上第一段代码所指的两种情况), 另一类是符号引用(不是指引用类型,这里指编译原理里面的概念). 而这两类信息是保存在.class文件中的常量池.</p>
<p>而且,常量池中的常量并不一定是只有编译期才能产生,即并非预置在.class文件中常量池的内容才能进入运行时常量池,在程序运行期间也可以将新的常量放入池中,如String类的intern()方法.</p>
<p><strong>因为字符串字面值保存在方法区中,如果程序运行过程中涉及长字符串或大量字符串拷贝,可能耗尽方法区</strong>.</p>
</li>
</ol>
<h2 id="类加载与类的初始化"><a href="#类加载与类的初始化" class="headerlink" title="类加载与类的初始化"></a>类加载与类的初始化</h2><p>类加载的过程如下</p>
<p><strong>加载</strong> –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; <strong>初始化</strong></p>
<p>java中类的加载,连接和初始化都是在运行期间完成的, 即在程序运行期间可以加载新的类,这就是所谓的动态加载. 如可以编写一个面向接口的应用程序, 等到运行时再指定实际的实现类,或者在运行过程中换掉实现类.</p>
<h4 id="1-什么是类加载"><a href="#1-什么是类加载" class="headerlink" title="1.什么是类加载?"></a>1.什么是类加载?</h4><p>类的加载指的是将.class文件加载到方法区中.</p>
<h4 id="2-类加载阶段做了哪些工作"><a href="#2-类加载阶段做了哪些工作" class="headerlink" title="2.类加载阶段做了哪些工作?"></a>2.类加载阶段做了哪些工作?</h4><ol>
<li>通过一个类的全限定名来获取定义此类的二进制流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构.</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>其中对于第1点来说,如何获取类的二进制流是可以自定义的,如从磁盘,从网络<br>就是<strong>自定义类加载器</strong>所应用场合,从另一个角度说,类加载器只完成了如下的任务:</p>
<blockquote>
<p>从哪里来获取定义此类的二进制流</p>
</blockquote>
<p>即只有第一点是程序员可以控制的.</p>
<p>对于第2点java.lang.Class类的对象,虚拟机规范中并没有规定此对象的存储位置,对于HotSpot虚拟机,因其特殊性,所以存放在方法区中.</p>
<h4 id="3-什么时候会进行类的加载"><a href="#3-什么时候会进行类的加载" class="headerlink" title="3.什么时候会进行类的加载?"></a>3.什么时候会进行类的加载?</h4><p>虚拟机规范中并没有约束类加载的时机,但是严格规定了类初始化的时机.</p>
<h4 id="4-类的准备阶段做的工作"><a href="#4-类的准备阶段做的工作" class="headerlink" title="4.类的准备阶段做的工作."></a>4.类的准备阶段做的工作.</h4><p>在对类进行初始化前,有一个准备阶段,该阶段主要做两方面工作</p>
<ol>
<li>为类变量(即static修饰的变量,在方法区)分配内存</li>
<li>为类变量设置初始值(这里说的初始值通常情况下指的是数据类型的零值)</li>
</ol>
<p>由2可知,在对类变量初始化前,已将其赋值为其类型的零值.但也有特殊情况,如下</p>
<pre><code>public static final int value = 123;
</code></pre><p>在准备阶段就会把value赋值为123, value称为ConstantValue属性</p>
<h4 id="5-类的初始化阶段所做的工作"><a href="#5-类的初始化阶段所做的工作" class="headerlink" title="5.类的初始化阶段所做的工作"></a>5.类的初始化阶段所做的工作</h4><p>在类的初始化阶段,根据程序员制定的主观计划去初始化<strong>类变量</strong>和其他资源.或者说,初始化阶段就是执行<strong>类构造器\&lt;clinit>()</strong>的过程,而该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{})合并产生.即\&lt;clinit>()方法包括以下两个内容</p>
<ol>
<li>类变量的赋值语句</li>
<li>静态语句块</li>
</ol>
<p>而且虚拟机会保证在了类的\&lt;clinit>()方法执行之前,父类的\&lt;clinit>()方法已经执行完毕.</p>
<p>另外,关于接口的初始化有些不同,<strong>接口中不能使用静态语句块,但可以有变量初始化的赋值操作</strong>, 执行接口的\&lt;clinit>()方法不需要先执行父接口的\&lt;clinit>()方法.只有当父接口中定义的变量使用时,父接口才会初始化.而且接口的实现类在初始化时也一样不会执行接口的\&lt;clinit>()方法.</p>
<p>虚拟机会保证一个类的\&lt;clinit>()方法在多线程环境中正确的加锁,同步.如果多个线程同时去初始化一个类,那么只会有一个线程进入\&lt;clinit>()方法,其它线程都需要阻塞等待,而且当一个线程退出\&lt;clinit>()方法后,其它线程被唤醒之后并不会再执行该方法,也就是说,<strong>同一个类加载器下,一个类型只会初始化一次</strong>(这也意味着,使用多个加载器可多次初始化一个类， 类的静态语句块不需要显示的同步)</p>
<p><strong>关于类加载器</strong></p>
<p>对于一个类,都需要由加载它的类加载器与该类本身共同确定其在Java虚拟机中的唯一性,如果同一个类被不同的加载器加载,那么这两个类也不是相同的.</p>
<h4 id="6-类初始化的时机"><a href="#6-类初始化的时机" class="headerlink" title="6.类初始化的时机"></a>6.类初始化的时机</h4><p>类初始化的时机分以下几种情况</p>
<ol>
<li>使用new关键字实例化对象的时候</li>
<li>读取或设置一个类的静态字段(被final修饰,已在编译期把结果放入常量池的静态字段除外, 举个例子?)</li>
<li>调用一个类的静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候</li>
<li>当初始化一个类的时候,如果发现其父类还没有进行初始化,需要先初始化其父类</li>
<li>虚拟机启动时要执行的主类(包含main()方法的类)</li>
</ol>
<p>以上场景称为对对一个类进行<strong>主动引用</strong>, 只有主动引用一个类时,才对类进行初始化,其它引用类的方式都不会触发初始化,称为<strong>被动引用</strong>, 主要有</p>
<ol>
<li>通过子类引用父类中定义的静态字段， 不会导致子类进行初始化</li>
<li>生成数组对象时,不会进行数组成员类型的初始化</li>
<li>经过常量传播优化(见深入理解JVM中的例子)</li>
</ol>
<p>注意,接口与类的初始化有些不同,不同于第5点,当一个接口初始化时,不要求其父接口也完成初始化.</p>
<h2 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h2><p>Java内存模型指的是Java是如何访问和使用内存的,其大致结构如下图所示</p>
<p><img src="/assets/pics/JMM.jpg" alt></p>
<p>从图中可以看出,有两种内存,一种是<strong>主内存</strong>, 一种是<strong>工作内存</strong>, JMM规定所有的变量(这里的变量指的是线程共享的变量,因为共享才有一致性问题,而局部变量,方法参数等这种是线程私有的变量,不会被共享,所以就不存在一致性问题)都存储在主内存中.每条线程还有自己的工作内存(类似于缓存), 线程对变量的所有操作对是在工作内存中,工作内存中保存着主内存中变量的一个副本,一个线程对变量的修改要想向另一个线程看到,必须将工作内存中的变量写回主内存中,再从主内存复制一份到工作内存才行.</p>
<p>因为存在同一个变量的多个副本,这就导致了一致性和同步问题,举例来说,假如三个线程对同一个变量进行加1操作,正确结果应该是加3,但可能三个线程对三个副本都只加了1,而一个线程对变量的改变并不能体现在其它线程当中,这就导致最后该变量只是加了1,结果就是错误的.</p>
<p>关于JMM有两个关键的概念:<strong>原子性</strong>与<strong>可见性</strong></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性仅仅指的是某一操作是原子的,一旦开始,便不能中断,它并没有涉及可见性的问题,即一个操作是原子的并不能保证其是可见的,在\&lt;java编程思想>中有下面这样的一段话</p>
<blockquote>
<p>It’s important to understand that atomicity and volatility are distinct concepts. An atomic operation on a non-volatile field will not necessarily be flushed to main memory, and so another task that reads that field will not necessarily see the new value. If multiple tasks are accessing a field, that field should be volatile; otherwise, the field should only be accessed via synchronization. Synchronization also causes flushing to main memory, so if a field is completely guarded by synchronized methods or blocks, it is not necessary to make it volatile.</p>
</blockquote>
<p>基本上说,一个操作是原子的,并不要求其将操作结果刷新到主内存中去,即并不是可见的.如果有多个线程访问同一个域,就要求该域为volatile, 或者使用<strong>synchronized</strong>关键字,其既保证了原子性,也会导致结果被刷新到主内存中去,即保证了可见性.</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是由JMM引起的,因为线程只能修改其工作内存,如果不将修改结果写回到主内存中去就会导致主内存中的值并非是最新值,其它线程从主内存拷贝到工作内存的值就是旧值.</p>
<p>可见性是针对一个线程的写操作来说的,当多个线程操作一个值时,如果一个线程修改了值,那么其它线程能”看到”其修改后的值,也就是”可见”的含义.</p>
<p>简而言之,可见就是说写操作对其它读操作是可见的.具体来说,当一个线程要从主内存拷贝一个变量到工作内存时,如果该变量之前被某一线程写过,那么会要求其先将写的结果刷新到主内存,然后其它线程才能读.</p>
<p>这里还有一个误解,可见性并不是保证各线程工作内存中变量值的一致,如果有3个线程已经把一个变量都读入工作内存中,然后一个线程修改了其工作内存,这个变化并不会同步到其它线程的工作内存中去.</p>
<p>换句话说,可见性仅仅保证了<strong>对一个变量在工作区的修改</strong>以及将该<strong>修改同步回主内存</strong>这两个操作是原子的.</p>
<p><strong>实现可见性有三种机制</strong></p>
<ol>
<li>volatile</li>
<li>synchronized</li>
<li>final:final修饰的为常量,常量不可修改,只是读</li>
</ol>
<p>和原子性与可见性相关的另一个问题就是<strong>同步</strong>, 或者说,这两个概念是由<strong>同步</strong>所引出的.</p>
<h4 id="那么什么是同步呢"><a href="#那么什么是同步呢" class="headerlink" title="那么什么是同步呢?"></a>那么什么是同步呢?</h4><p><strong>背景</strong></p>
<p>多个线程共同完成一项工作,并且要有一定的顺序.这样这项工作才能被正确的完成,如果每次执行时,顺序是随机的,那么结果就是不可预测的.同步就是要保证多个线程的执行要有一定的顺序.</p>
<p><strong>举个例子</strong></p>
<p>有两个线程,都对一个变量进行加1操作, 初始值为</p>
<p>i = 0;</p>
<p>进行的操作为</p>
<p>i++</p>
<p>首先说正确的结果应该是2.</p>
<p>那么怎么样能保证其执行顺序得到2呢?单独的使用原子性或可见性并不能解决问题</p>
<p><strong>单独使用原子性</strong></p>
<p>假设i++是原子的,这意味的该操作不能被打断,从微观来看,该操作指的是:</p>
<p>线程从主内存拷贝值到工作内存 –&gt; 工作内存的变量加1</p>
<p>此时,虽然工作内存的i = 1,但并没有写回主内存,所以第2个线程读到的依然是0,最后结果是为1</p>
<p><strong>单独使用可见性</strong></p>
<p>假设</p>
<p>volatile i = 0;</p>
<p>i++不是原子的,分为 读 –&gt; 加1 –&gt; 写操作</p>
<p>那么可能存在以下这种情况</p>
<p>一个线程从主内存读i到工作内存之后,切换到另一线程从主内存读i到工作内存,再切换回第一个线程对其进行修改,因为其可见性,所其修改会同步回主内存,但第二个线程的工作内存中依然是修改前的值,所以最终结果也是不正确的.</p>
<p>由此可见,对于以上例子,单保证原子性或可见性并不能保证同步,只有当两个性质同时具有时能保证同步.而使用<strong>synchronized</strong>关键字是一种比较方便的做法,它可保证原子性和可见性.</p>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p><strong>什么是先行发生?</strong></p>
<p>先行发生是内存模型中定义的两项操作之间的偏序关系, 如果说操作A先行发生于B, 说明操作A产生的影响能被操作B观察到, “影响”包括修改了内存中共享变量的值,发送了消息,调用了方法等.</p>
<p><strong>那么同步与先行发生有什么关系呢?</strong></p>
<p>同步其实就是为了某种有序性,而由上面讨论可知,有序性要靠volatile和synchronized来保证. 而先行发生说的也是某种有序性.如果说两个操作A,B符合先行发生,那么其就是有序的,也就不需要使用volatile和synchronized来保证A,B操作的同步性了.</p>
<p>在Java内存模型中,已经包含了某些操作符合先行发生原则,所以这些操作就不需要使用volatile和synchronized来显示的确保操作的顺序了,可以说,是一种内置的同步机制.如果没有这种内置的同步机制,那么写起代码来需要使用大量的volatile和synchronized,这样就会很繁琐.</p>
<p><strong>内置的符合先行发生原则的操作为</strong></p>
<ol>
<li>程序次序规则</li>
<li>管程锁定规则</li>
<li>volatile变量规则</li>
<li>线程启动规则</li>
<li>线程终止规则</li>
<li>线程中断规则</li>
<li>对象终结规则</li>
<li>传递性</li>
</ol>
<p>以上具体内容参考&lt;深入理解JVM&gt;</p>
<p><strong>利用先行发生原则判断是否需要显示的synchronized</strong></p>
<p>好,现在当我们有两个操作,需要同步,即保证其有序时,可以首先判断其是否属于以上8种情况,属于的话就可以利用内置的同步机制保证其同步性,就不必显示的使用synchronized,如果不属于就需要显示的使用synchronized.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">asanelder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lingnanlu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/lingnanlu" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">asanelder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
